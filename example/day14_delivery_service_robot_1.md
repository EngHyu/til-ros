# 딜리버리 서비스 로봇 만들기 소개
## 모바일 로봇의 목적
- 원하는 위치로 이동 => SLAM, Navigation
- 서비스 제공 => 무엇을 고려해야 할까?
# 배달 서비스 로봇
안드로이드 태블릿에서 유저가 요청하는 메뉴를 서빙하는 로봇을 만들어 보겠습니다.
## 고려할 점
- 시스템 구성
- 고객 니즈 고려
- 인터페이스
## 시스템 구성
서비스 마스터 <-> 서비스 코어 <-> 서비스 슬레이브

각각의 태블릿이 마스터, 각각의 서비스 로봇이 슬레이브가 되며, 이를 중개해주는 서비스 코어가 있는 구성입니다. 주문을 접수받은 로봇이 특정 위치로 이동하면, 위치에 해당하는 물건을 사람이 건네주고 다시 주문 받은 곳으로 이동하는 형태입니다.
## 서비스 코어
서비스 코어는 데이터베이스의 일종입니다. 고객으로부터 주문을 받을 때, 그 주문의 처리 가능 여부와 로봇의 서비스 처리 스케쥴링을 담당하는 역할을 수행해야 합니다.
## 서비스 마스터
서비스 마스터는 고객의 주문을 입력받고 주문 내역을 서비스 코어에 전달합니다. 더불어 고객이 주문 가능한 아이템 목록을 제시하고 로봇의 서비스 수행 상황을 고객에게 전달하는 역할을 합니다. 이를 위해 서비스 코어의 데이터베이스와 싱크를 맞출 필요가 있습니다.
## 서비스 슬레이브
고객이 주문한 제품 배달을 물리적으로 수행하기 위한 객체 또는 로봇 플랫폼으로써 서비스 수행 가운데 서비스 상황을 실시간으로 서비스 코어에 업데이트 합니다.
# 시스템 설계
구성이 끝났으면 다음으로 각 영역의 노드들이 어떤 메시지를 주고 받아야 하는지 결정해야 합니다.

태블릿 -- 태블릿 ID, 주문한 아이템 --> 서비스 코어 -- 목표 위치 좌표 --> 서비스 로봇

서비스 로봇 -- 로봇의 서비스 상황 --> 서비스 코어 -- 주문 가능한 아이템, 로봇의 서비스 상황 --> 태블릿
## rqt_graph
rqt_graph를 통해 확인하게 되면, 3개의 그룹과 service_core로 이루어진 것을 볼 수 있습니다.
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FKVGQk%2FbtqFHqYCnlO%2Fyv5WUepgKDERwxFsRZwGC0%2Fimg.png)
각 그룹에는 태블릿과 서비스 로봇에 관련된 모든 노드가 namespace 안에 쌍을 이루고 있습니다. 각 그룹을 namespace로 관리하는 이유는, namespace가 같을 경우 노드 간 충돌이 일어나 실행이 불가능하기 때문입니다.
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FyOMbM%2FbtqFDxZqVcv%2FF9mIa8aYymWdYeZBQrZeLk%2Fimg.png)
service_core는 세 그룹 모두 관할해야 하기 때문에 어느 그룹에도 종속되지 않습니다. service_core는 /pad_order를 통해 주문을 전달받고, /move_base/action_topics으로 길찾기 및 목적지 도착 성공 여부를 받습니다. 또한 /service_status 토픽으로 상황을 전달하고, /play_sound_file을 통해 현재 상황을 표현하는 음성 파일의 파일 위치를 전달합니다. /move_base_simple/goal을 통해 로봇의 목표지점 좌표를 전달합니다.

자세한 코드는 아래 깃허브 주소에서 확인할 수 있습니다.

https://github.com/ROBOTIS-GIT/turtlebot3_deliver
